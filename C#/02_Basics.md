# <p align="center"> C# basics </p> 
 
## Data Type
There are mainly 2 data types: value type and reference type. Pointer is also considered a special data type containing memory address of the others. `&` is address operator to determine address and `*` is indirection operator to access value of the address.

There are 9 primitive data value types in C#: byte, short, int, long, float, double, decimal, char, bool.

Struct is value data type represent data structures, which can contain a parameterized constructor, static constructor, constants, fields, methods, properties, indexers, operators, events, and nested types. Its object can be created with or without new operator. Struct can implement interfaces but cannot inherit any class or other struct. Struct member cannot be specified as abstract, sealed, virtual or protect.

Local variables can be declared without giving an explicit type. The `var` keyword instructs the compiler to infer the type of the variable from the expression on the right side of the initialization statement.
```cs
// i is compiled as an int
var i = 5;
// s is compiled as a string
var s = "Hello";
// a is compiled as int[]
var a = new[] { 0, 1, 2 };
```

## Variables
There are 4 kind of variables: non-static variable, static variable, constant and read-only variable. Constant and read-only are similar to each other except read-only allows users not to initialize variables when declaring.

## Anonymous types, dynamic types, nullable types
### Anonymous type
Anonymous types provide a convenient way to encapsulate a set of read-only properties into a single object without having to explicitly define a type first. The type name is generated by the compiler and is not available at the source code level. The type of each property is inferred by the compiler.
```cs
var v = new { Amount = 108, Message = "Hello" };
Console.WriteLine(v.Amount + v.Message);
```
Anonymous types only contain one or more public read-only properties. No other kinds of class members, such as methods or events, are valid. The expression that is used to initialize a property cannot be null, an anonymous function, or a pointer type.

Anonymous types support non-destructive mutation in the form of `with` expressions. This enables you to create a new instance of an anonymous type where one or more properties have new values
```cs
var apple = new { Item = "apples", Price = 1.35 };
var onSale = apple with { Price = 0.79 };
```

In many cases of implicit type, the use of `var` is just a syntactic convenience. However, when a variable is initialized with an anonymous type you must declare the variable as var if you need to access the properties of the object at a later point.

### Dynamic type
The dynamic type is a static type. It is used to avoid the compile-time type checking. The compiler does not check the type of the dynamic type variable at compile time, instead of this, the compiler gets the type at the run time. The dynamic type variable is created using `dynamic` keyword.
```cs
dynamic value1 = "hi";
dynamic value2 = 123234;
dynamic value3 = 2132.55;
dynamic value4 = false;
```

For example, assume that we have method exampleMethod1 in the following code has only one parameter,
```cs
static void Main(string[] args)
{
    ExampleClass ec = new ExampleClass();
    ec.exampleMethod1(10, 4); // this causes compile error

    dynamic dynamic_ec = new ExampleClass();
    dynamic_ec.exampleMethod1(10, 4); // this only causes runtime exception
    dynamic_ec.someMethod("some argument", 7, null);
    dynamic_ec.nonexistentMethod(); // all 3 line above did not cause compile error
}
```

Most results of operations on `dynamic` is also dynamic, except conversion dynamic to other type and constructor calls that include dynamic arguments. Type conversion with dynamic can be done implicitly.

### Nullable type
A nullable value type `T?` represents all values of its underlying value type `T` and an additional null value. For example, you can assign any of the following three values to a `bool?` variable: `true`, `false`, or `null`. An underlying value type `T` cannot be a nullable value type itself.

If you want to assign a value of a nullable value type to a non-nullable value type variable, you might need to specify the value to be assigned in place of null, otherwise it will throw an exception if value is null. Use the null-coalescing operator `??` to do that
```cs
int? a = 28;
int b = a ?? -1;
Console.WriteLine($"b is {b}");  // output: b is 28

int? c = null;
int d = c ?? -1;
Console.WriteLine($"d is {d}");  // output: d is -1
```

Box and unbox nullable: an instance of a nullable value type `T?` is boxed,
* If `HasValue` returns false, the null reference is produced.
* If `HasValue` returns true, the corresponding value of the underlying value type `T` is boxed, not the instance of `Nullable<T>`.
```cs
int a = 41;
object aBoxed = a;
int? aNullable = (int?)aBoxed;
Console.WriteLine($"Value of aNullable: {aNullable}"); // Value of aNullable: 41
```

## Pass-by-value and Pass-by-reference

* `ref` specifies that this parameter is passed by reference and *may be* read or written by the called method.
```cs
void Method(ref int refArgument)
{
    refArgument = refArgument + 44;
}

int number = 1;
Method(ref number);
Console.WriteLine(number); // 45
```

* `out` specifies that this parameter is passed by reference and is *must be* written by the called method. It is like the `ref` keyword, except that `ref` requires that the variable be initialized before it is passed
```cs
void Method(out int number)
{
    number = 44;
}

int num;
Method(out num);
Console.WriteLine(num);  // 44
```

* `in` specifies that this parameter is passed by reference but is only read by the called method. It is like the `ref` or `out` keywords, except that in arguments cannot be modified by the called method

## Arrays
[Read here](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/arrays)

## Stack, Heap and Garbage Collector
